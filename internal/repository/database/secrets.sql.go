// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: secrets.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const cleanup = `-- name: Cleanup :exec
DELETE FROM secrets
WHERE
    expires_at < $1 or
    (burn_after_read and already_read)
`

func (q *Queries) Cleanup(ctx context.Context, expiresAt time.Time) error {
	_, err := q.db.Exec(ctx, cleanup, expiresAt)
	return err
}

const deleteSecret = `-- name: DeleteSecret :exec
DELETE FROM secrets WHERE public_id = $1
`

func (q *Queries) DeleteSecret(ctx context.Context, publicID string) error {
	_, err := q.db.Exec(ctx, deleteSecret, publicID)
	return err
}

const getSecret = `-- name: GetSecret :one
SELECT public_id, retrieval_token, nonce, encrypted_data, expires_at, burn_after_read, already_read, deletion_token FROM secrets WHERE public_id = $1
`

func (q *Queries) GetSecret(ctx context.Context, publicID string) (Secret, error) {
	row := q.db.QueryRow(ctx, getSecret, publicID)
	var i Secret
	err := row.Scan(
		&i.PublicID,
		&i.RetrievalToken,
		&i.Nonce,
		&i.EncryptedData,
		&i.ExpiresAt,
		&i.BurnAfterRead,
		&i.AlreadyRead,
		&i.DeletionToken,
	)
	return i, err
}

const markAsRead = `-- name: MarkAsRead :exec
UPDATE secrets
SET already_read = true
WHERE public_id = $1
AND already_read = false
`

func (q *Queries) MarkAsRead(ctx context.Context, publicID string) error {
	_, err := q.db.Exec(ctx, markAsRead, publicID)
	return err
}

const storeSecret = `-- name: StoreSecret :exec
INSERT INTO secrets (public_id, retrieval_token, nonce, encrypted_data, expires_at, burn_after_read, already_read, deletion_token)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
`

type StoreSecretParams struct {
	PublicID       string
	RetrievalToken string
	Nonce          string
	EncryptedData  string
	ExpiresAt      time.Time
	BurnAfterRead  bool
	AlreadyRead    bool
	DeletionToken  sql.NullString
}

func (q *Queries) StoreSecret(ctx context.Context, arg StoreSecretParams) error {
	_, err := q.db.Exec(ctx, storeSecret,
		arg.PublicID,
		arg.RetrievalToken,
		arg.Nonce,
		arg.EncryptedData,
		arg.ExpiresAt,
		arg.BurnAfterRead,
		arg.AlreadyRead,
		arg.DeletionToken,
	)
	return err
}
